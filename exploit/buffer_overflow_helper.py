#!/usr/bin/env python3
"""
Red Team Tools - Buffer Overflow Helper
For educational and authorized security testing only
"""

import struct
import string
import os
import sys

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from utils import *


class BufferOverflowHelper:
    """Buffer overflow development helper"""
    
    def __init__(self):
        pass
    
    def generate_pattern(self, length: int) -> str:
        """Generate unique pattern for offset finding"""
        pattern = ""
        
        upper = string.ascii_uppercase
        lower = string.ascii_lowercase
        digits = string.digits
        
        for u in upper:
            for l in lower:
                for d in digits:
                    if len(pattern) >= length:
                        return pattern[:length]
                    pattern += f"{u}{l}{d}"
        
        return pattern[:length]
    
    def find_offset(self, pattern: str, value: str) -> int:
        """Find offset of value in pattern"""
        # Handle hex input
        if value.startswith("0x"):
            value = value[2:]
        
        # Try as hex (little endian)
        if len(value) == 8:
            try:
                # Convert hex to bytes and reverse (little endian)
                bytes_val = bytes.fromhex(value)
                # Try both endianness
                le_str = bytes_val[::-1].decode('ascii', errors='ignore')
                be_str = bytes_val.decode('ascii', errors='ignore')
                
                offset = pattern.find(le_str)
                if offset != -1:
                    return offset
                
                offset = pattern.find(be_str)
                if offset != -1:
                    return offset
            except:
                pass
        
        # Try as string
        offset = pattern.find(value)
        return offset
    
    def generate_cyclic(self, length: int, n: int = 4) -> bytes:
        """Generate cyclic pattern (de Bruijn sequence)"""
        k = len(string.ascii_lowercase)
        a = [0] * k * n
        sequence = []
        
        def db(t, p):
            if t > n:
                if n % p == 0:
                    sequence.extend(a[1:p + 1])
            else:
                a[t] = a[t - p]
                db(t + 1, p)
                for j in range(a[t - p] + 1, k):
                    a[t] = j
                    db(t + 1, t)
        
        db(1, 1)
        
        result = ''.join(string.ascii_lowercase[i] for i in sequence)
        return result[:length].encode()
    
    def pack_address(self, address: int, arch: str = "x86", endian: str = "little") -> bytes:
        """Pack address for payload"""
        if arch == "x86":
            if endian == "little":
                return struct.pack("<I", address)
            else:
                return struct.pack(">I", address)
        elif arch == "x64":
            if endian == "little":
                return struct.pack("<Q", address)
            else:
                return struct.pack(">Q", address)
        else:
            return b""
    
    def generate_nop_sled(self, length: int, arch: str = "x86") -> bytes:
        """Generate NOP sled"""
        if arch == "x86" or arch == "x64":
            return b"\x90" * length
        elif arch == "arm":
            # ARM NOP: mov r0, r0
            return b"\x00\x00\xa0\xe1" * (length // 4)
        else:
            return b"\x90" * length
    
    def generate_payload_skeleton(self, offset: int, ret_addr: int, 
                                  nop_size: int = 16, 
                                  shellcode: bytes = b"",
                                  arch: str = "x86") -> bytes:
        """Generate complete payload skeleton"""
        # Padding to reach return address
        padding = b"A" * offset
        
        # Return address
        ret = self.pack_address(ret_addr, arch)
        
        # NOP sled
        nops = self.generate_nop_sled(nop_size, arch)
        
        # Shellcode placeholder if not provided
        if not shellcode:
            shellcode = b"\xcc" * 4  # INT3 breakpoints
        
        payload = padding + ret + nops + shellcode
        
        return payload
    
    def find_bad_chars(self, test_string: bytes, received: bytes) -> list:
        """Find bad characters by comparing sent vs received"""
        bad_chars = []
        
        for i, (sent, recv) in enumerate(zip(test_string, received)):
            if sent != recv:
                bad_chars.append(hex(sent))
        
        return bad_chars
    
    def generate_all_chars(self, exclude: list = None) -> bytes:
        """Generate all characters for bad char testing"""
        if exclude is None:
            exclude = [0x00]  # Null byte
        
        chars = bytes([i for i in range(256) if i not in exclude])
        return chars
    
    def format_payload(self, payload: bytes, format_type: str = "python") -> str:
        """Format payload for different uses"""
        if format_type == "python":
            hex_str = ''.join([f'\\x{b:02x}' for b in payload])
            return f'payload = b"{hex_str}"'
        
        elif format_type == "c":
            hex_str = ''.join([f'\\x{b:02x}' for b in payload])
            return f'char payload[] = "{hex_str}";'
        
        elif format_type == "hex":
            return payload.hex()
        
        elif format_type == "base64":
            import base64
            return base64.b64encode(payload).decode()
        
        else:
            return repr(payload)
    
    def calculate_padding(self, buffer_size: int, saved_ebp: int = 4, 
                         arch: str = "x86") -> dict:
        """Calculate padding for stack-based overflow"""
        ptr_size = 4 if arch == "x86" else 8
        
        return {
            "buffer_size": buffer_size,
            "saved_ebp": saved_ebp,
            "total_to_ret": buffer_size + saved_ebp,
            "ret_address_offset": buffer_size + saved_ebp,
            "shellcode_start": buffer_size + saved_ebp + ptr_size
        }
    
    def rop_gadget_format(self, gadgets: list, arch: str = "x86") -> bytes:
        """Format ROP chain from gadget addresses"""
        chain = b""
        for gadget in gadgets:
            chain += self.pack_address(gadget, arch)
        return chain


def interactive_mode():
    """Interactive mode for buffer overflow helper"""
    print_banner("BOF HELPER", color="red")
    warning("For educational and authorized security testing only!")
    
    helper = BufferOverflowHelper()
    
    options = [
        "Generate Pattern",
        "Find Pattern Offset",
        "Generate Bad Char Test",
        "Create Payload Skeleton",
        "Pack Address",
        "Calculate Padding"
    ]
    
    choice = menu_selector(options, "Select Option")
    
    if choice == 0:
        return
    
    elif choice == 1:
        length = int(prompt("Pattern length") or "500")
        pattern = helper.generate_pattern(length)
        
        print(f"\n{G}Pattern ({len(pattern)} bytes):{RESET}")
        print(pattern)
        
        if confirm("Save to file?"):
            with open("pattern.txt", "w") as f:
                f.write(pattern)
            success("Saved to pattern.txt")
    
    elif choice == 2:
        length = int(prompt("Original pattern length") or "500")
        pattern = helper.generate_pattern(length)
        
        value = prompt("Enter EIP value (hex, e.g., 41386941 or 0x41386941)")
        
        offset = helper.find_offset(pattern, value)
        
        if offset != -1:
            success(f"Offset found: {offset}")
            info(f"EIP is at offset {offset}")
        else:
            error("Offset not found in pattern")
    
    elif choice == 3:
        exclude_input = prompt("Exclude bytes (comma-separated hex, e.g., 00,0a,0d)") or "00"
        exclude = [int(x.strip(), 16) for x in exclude_input.split(",")]
        
        chars = helper.generate_all_chars(exclude)
        
        print(f"\n{G}Bad char test string ({len(chars)} bytes):{RESET}")
        print(helper.format_payload(chars, "python"))
    
    elif choice == 4:
        offset = int(prompt("Offset to EIP"))
        ret_input = prompt("Return address (hex, e.g., 0x12345678)")
        ret_addr = int(ret_input, 16)
        
        nop_size = int(prompt("NOP sled size") or "16")
        arch = prompt("Architecture (x86/x64)") or "x86"
        
        payload = helper.generate_payload_skeleton(offset, ret_addr, nop_size, arch=arch)
        
        print(f"\n{G}Payload Skeleton ({len(payload)} bytes):{RESET}")
        print(helper.format_payload(payload, "python"))
        
        print(f"\n{Y}Structure:{RESET}")
        print(f"  Padding: {offset} bytes (A's)")
        print(f"  Return Address: {ret_input}")
        print(f"  NOP Sled: {nop_size} bytes")
        print(f"  Shellcode: [insert here]")
    
    elif choice == 5:
        addr_input = prompt("Address (hex, e.g., 0x12345678)")
        addr = int(addr_input, 16)
        arch = prompt("Architecture (x86/x64)") or "x86"
        endian = prompt("Endianness (little/big)") or "little"
        
        packed = helper.pack_address(addr, arch, endian)
        
        print(f"\n{G}Packed Address:{RESET}")
        print(f"  Hex: {packed.hex()}")
        print(f"  Python: {repr(packed)}")
        c_format = ''.join(['\\\\x{:02x}'.format(b) for b in packed])
        print(f"  C: {c_format}")
    
    elif choice == 6:
        buffer_size = int(prompt("Buffer size"))
        saved_ebp = int(prompt("Saved EBP size") or "4")
        arch = prompt("Architecture (x86/x64)") or "x86"
        
        calc = helper.calculate_padding(buffer_size, saved_ebp, arch)
        
        print(f"\n{C}Padding Calculation:{RESET}")
        print(f"  Buffer Size: {calc['buffer_size']}")
        print(f"  Saved EBP: {calc['saved_ebp']}")
        print(f"  Total to Return Address: {calc['total_to_ret']}")
        print(f"  Shellcode Start: {calc['shellcode_start']}")


if __name__ == "__main__":
    interactive_mode()
