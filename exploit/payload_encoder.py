#!/usr/bin/env python3
"""
Red Team Tools - Payload Encoder
For educational and authorized security testing only
"""

import base64
import random
import string
import zlib
import os
import sys

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from utils import *


class PayloadEncoder:
    """Payload encoding and obfuscation tool"""
    
    def __init__(self):
        pass
    
    def xor_encode(self, data: bytes, key: bytes = None) -> tuple:
        """XOR encode data with key"""
        if key is None:
            key = bytes([random.randint(1, 255) for _ in range(8)])
        
        encoded = bytes([data[i] ^ key[i % len(key)] for i in range(len(data))])
        return encoded, key
    
    def xor_decode(self, data: bytes, key: bytes) -> bytes:
        """XOR decode data with key"""
        return bytes([data[i] ^ key[i % len(key)] for i in range(len(data))])
    
    def base64_encode(self, data: bytes) -> str:
        """Base64 encode"""
        return base64.b64encode(data).decode()
    
    def base64_decode(self, data: str) -> bytes:
        """Base64 decode"""
        return base64.b64decode(data)
    
    def base32_encode(self, data: bytes) -> str:
        """Base32 encode"""
        return base64.b32encode(data).decode()
    
    def base32_decode(self, data: str) -> bytes:
        """Base32 decode"""
        return base64.b32decode(data)
    
    def hex_encode(self, data: bytes) -> str:
        """Hex encode"""
        return data.hex()
    
    def hex_decode(self, data: str) -> bytes:
        """Hex decode"""
        return bytes.fromhex(data)
    
    def rot13(self, text: str) -> str:
        """ROT13 encoding"""
        result = []
        for char in text:
            if 'a' <= char <= 'z':
                result.append(chr((ord(char) - ord('a') + 13) % 26 + ord('a')))
            elif 'A' <= char <= 'Z':
                result.append(chr((ord(char) - ord('A') + 13) % 26 + ord('A')))
            else:
                result.append(char)
        return ''.join(result)
    
    def caesar_cipher(self, text: str, shift: int = 3) -> str:
        """Caesar cipher encoding"""
        result = []
        for char in text:
            if 'a' <= char <= 'z':
                result.append(chr((ord(char) - ord('a') + shift) % 26 + ord('a')))
            elif 'A' <= char <= 'Z':
                result.append(chr((ord(char) - ord('A') + shift) % 26 + ord('A')))
            else:
                result.append(char)
        return ''.join(result)
    
    def compress_encode(self, data: bytes) -> bytes:
        """Compress and base64 encode"""
        compressed = zlib.compress(data)
        return base64.b64encode(compressed)
    
    def compress_decode(self, data: bytes) -> bytes:
        """Decompress base64 data"""
        decoded = base64.b64decode(data)
        return zlib.decompress(decoded)
    
    def unicode_encode(self, text: str) -> str:
        """Unicode escape encoding"""
        return ''.join([f'\\u{ord(c):04x}' for c in text])
    
    def html_encode(self, text: str) -> str:
        """HTML entity encoding"""
        return ''.join([f'&#{ord(c)};' for c in text])
    
    def url_encode(self, text: str) -> str:
        """URL percent encoding"""
        from urllib.parse import quote
        return quote(text, safe='')
    
    def generate_powershell_payload(self, command: str, encode: bool = True) -> str:
        """Generate encoded PowerShell payload"""
        if encode:
            # UTF-16LE encode for PowerShell
            encoded = base64.b64encode(command.encode('utf-16-le')).decode()
            return f"powershell -enc {encoded}"
        else:
            return f"powershell -Command \"{command}\""
    
    def generate_python_payload(self, code: str, encode: bool = True) -> str:
        """Generate encoded Python payload"""
        if encode:
            encoded = base64.b64encode(code.encode()).decode()
            return f"python -c \"import base64;exec(base64.b64decode('{encoded}'))\""
        else:
            escaped = code.replace('"', '\\"')
            return f'python -c "{escaped}"'
    
    def generate_bash_payload(self, command: str, encode: bool = True) -> str:
        """Generate encoded Bash payload"""
        if encode:
            encoded = base64.b64encode(command.encode()).decode()
            return f"echo {encoded} | base64 -d | bash"
        else:
            return command
    
    def obfuscate_string(self, text: str, method: str = "concat") -> str:
        """Obfuscate string using various methods"""
        if method == "concat":
            # String concatenation
            parts = [f'"{c}"' for c in text]
            return " + ".join(parts)
        
        elif method == "chr":
            # Chr() function
            codes = [f"chr({ord(c)})" for c in text]
            return " + ".join(codes)
        
        elif method == "reverse":
            # Reversed string
            return f'"{text[::-1]}"[::-1]'
        
        elif method == "hex":
            # Hex escape
            return '"' + ''.join([f'\\x{ord(c):02x}' for c in text]) + '"'
        
        else:
            return f'"{text}"'
    
    def multi_encode(self, data: bytes, layers: list) -> bytes:
        """Apply multiple encoding layers"""
        result = data
        applied = []
        
        for layer in layers:
            if layer == "base64":
                result = self.base64_encode(result).encode()
                applied.append("base64")
            elif layer == "hex":
                result = self.hex_encode(result).encode()
                applied.append("hex")
            elif layer == "xor":
                result, key = self.xor_encode(result)
                applied.append(f"xor(key={key.hex()})")
            elif layer == "compress":
                result = self.compress_encode(result)
                applied.append("compress")
        
        return result, applied


def interactive_mode():
    """Interactive mode for payload encoding"""
    print_banner("PAYLOAD ENCODER", color="red")
    warning("For educational and authorized security testing only!")
    
    encoder = PayloadEncoder()
    
    options = [
        "Base64 Encode/Decode",
        "XOR Encode/Decode",
        "Hex Encode/Decode",
        "Generate PowerShell Payload",
        "Generate Python Payload",
        "Multi-Layer Encoding",
        "String Obfuscation"
    ]
    
    choice = menu_selector(options, "Select Option")
    
    if choice == 0:
        return
    
    elif choice == 1:
        action = prompt("Encode or Decode (e/d)") or "e"
        data = prompt("Enter data")
        
        if action.lower() == "e":
            result = encoder.base64_encode(data.encode())
            print(f"\n{G}Base64 Encoded:{RESET}")
            print(result)
        else:
            result = encoder.base64_decode(data)
            print(f"\n{G}Base64 Decoded:{RESET}")
            print(result.decode())
    
    elif choice == 2:
        action = prompt("Encode or Decode (e/d)") or "e"
        
        if action.lower() == "e":
            data = prompt("Enter data")
            key_input = prompt("Key (hex, or leave empty for random)")
            
            if key_input:
                key = bytes.fromhex(key_input)
            else:
                key = None
            
            encoded, used_key = encoder.xor_encode(data.encode(), key)
            
            print(f"\n{G}XOR Encoded:{RESET}")
            print(f"Key: {used_key.hex()}")
            print(f"Data (hex): {encoded.hex()}")
            print(f"Data (base64): {base64.b64encode(encoded).decode()}")
        else:
            data = prompt("Enter data (hex)")
            key = prompt("Enter key (hex)")
            
            decoded = encoder.xor_decode(bytes.fromhex(data), bytes.fromhex(key))
            print(f"\n{G}XOR Decoded:{RESET}")
            print(decoded.decode(errors='replace'))
    
    elif choice == 3:
        action = prompt("Encode or Decode (e/d)") or "e"
        data = prompt("Enter data")
        
        if action.lower() == "e":
            result = encoder.hex_encode(data.encode())
            print(f"\n{G}Hex Encoded:{RESET}")
            print(result)
        else:
            result = encoder.hex_decode(data)
            print(f"\n{G}Hex Decoded:{RESET}")
            print(result.decode())
    
    elif choice == 4:
        command = prompt("Enter PowerShell command")
        
        payload = encoder.generate_powershell_payload(command)
        
        print(f"\n{G}Encoded PowerShell Payload:{RESET}")
        print(payload)
    
    elif choice == 5:
        code = prompt("Enter Python code")
        
        payload = encoder.generate_python_payload(code)
        
        print(f"\n{G}Encoded Python Payload:{RESET}")
        print(payload)
    
    elif choice == 6:
        data = prompt("Enter data")
        layers_input = prompt("Encoding layers (comma-separated: base64,xor,hex)")
        layers = [l.strip() for l in layers_input.split(",")]
        
        result, applied = encoder.multi_encode(data.encode(), layers)
        
        print(f"\n{G}Multi-Layer Encoded:{RESET}")
        print(f"Layers applied: {' -> '.join(applied)}")
        print(f"Result: {result.decode(errors='replace')}")
    
    elif choice == 7:
        text = prompt("Enter string to obfuscate")
        method = prompt("Method (concat/chr/reverse/hex)") or "concat"
        
        result = encoder.obfuscate_string(text, method)
        
        print(f"\n{G}Obfuscated ({method}):{RESET}")
        print(result)


if __name__ == "__main__":
    interactive_mode()
